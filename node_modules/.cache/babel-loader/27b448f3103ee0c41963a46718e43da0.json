{"ast":null,"code":"import _pt from \"prop-types\";\nimport React, { useMemo, useCallback, useState, useEffect, useRef } from 'react';\nimport throttle from 'lodash.throttle';\nconst animatedClass = 'animate__animated';\nconst serverSide = typeof window === 'undefined';\nexport const AnimationOnScroll = _ref => {\n  let {\n    offset = 150,\n    duration = 1,\n    style: styleProps,\n    className: classNameProps,\n    initiallyVisible = false,\n    animateIn,\n    afterAnimatedIn,\n    animateOut,\n    delay = 0,\n    animatePreScroll = true,\n    afterAnimatedOut,\n    scrollableParentSelector,\n    animateOnce = false,\n    children\n  } = _ref;\n  const [classes, setClasses] = useState(animatedClass);\n  const [style, setStyle] = useState({\n    animationDuration: `${duration}s`,\n    opacity: initiallyVisible ? 1 : 0\n  });\n  const node = useRef(null);\n  const animating = useRef(false);\n  const visibilityRef = useRef({\n    onScreen: false,\n    inViewport: false\n  });\n  const delayedAnimationTORef = useRef(undefined);\n  const callbackTORef = useRef(undefined);\n  const scrollableParentRef = useRef(window);\n  const getElementTop = useCallback(elm => {\n    let yPos = 0;\n\n    while (elm && elm.offsetTop !== undefined && elm.clientTop !== undefined) {\n      yPos += elm.offsetTop + elm.clientTop;\n      elm = elm.offsetParent;\n    }\n\n    return yPos;\n  }, []);\n  const getScrollPos = useCallback(() => {\n    if (scrollableParentRef.current.pageYOffset !== undefined) {\n      return scrollableParentRef.current.pageYOffset;\n    }\n\n    return scrollableParentRef.current.scrollTop;\n  }, [scrollableParentRef]);\n  const getScrollableParentHeight = useCallback(() => {\n    if (scrollableParentRef.current.innerHeight !== undefined) {\n      return scrollableParentRef.current.innerHeight;\n    }\n\n    return scrollableParentRef.current.clientHeight;\n  }, [scrollableParentRef]);\n  const getViewportTop = useCallback(() => {\n    return getScrollPos() + offset;\n  }, [offset, getScrollPos]);\n  const getViewportBottom = useCallback(() => {\n    return getScrollPos() + getScrollableParentHeight() - offset;\n  }, [offset, getScrollPos, getScrollableParentHeight]);\n  const isInViewport = useCallback(y => {\n    return y >= getViewportTop() && y <= getViewportBottom();\n  }, [getViewportTop, getViewportBottom]);\n  const isAboveViewport = useCallback(y => {\n    return y < getViewportTop();\n  }, [getViewportTop]);\n  const isBelowViewport = useCallback(y => {\n    return y > getViewportBottom();\n  }, [getViewportBottom]);\n  const inViewport = useCallback((elementTop, elementBottom) => {\n    return isInViewport(elementTop) || isInViewport(elementBottom) || isAboveViewport(elementTop) && isBelowViewport(elementBottom);\n  }, [isInViewport, isAboveViewport, isBelowViewport]);\n  const isAboveScreen = useCallback(y => {\n    return y < getScrollPos();\n  }, [getScrollPos]);\n  const isBelowScreen = useCallback(y => {\n    return y > getScrollPos() + getScrollableParentHeight();\n  }, [getScrollPos, getScrollableParentHeight]);\n  const onScreen = useCallback((elementTop, elementBottom) => {\n    return !isAboveScreen(elementBottom) && !isBelowScreen(elementTop);\n  }, [isAboveScreen, isBelowScreen]);\n  const getVisibility = useCallback(() => {\n    const elementTop = getElementTop(node.current) - getElementTop(scrollableParentRef.current);\n    const elementBottom = elementTop + node.current.clientHeight;\n    return {\n      inViewport: inViewport(elementTop, elementBottom),\n      onScreen: onScreen(elementTop, elementBottom)\n    };\n  }, [getElementTop, node, inViewport, onScreen, scrollableParentRef]);\n  const visibilityHasChanged = useCallback((previousVis, currentVis) => {\n    return previousVis.inViewport !== currentVis.inViewport || previousVis.onScreen !== currentVis.onScreen;\n  }, []);\n  const animate = useCallback((animation, callback) => {\n    delayedAnimationTORef.current = setTimeout(() => {\n      animating.current = true;\n      setClasses(`${animatedClass} ${animation}`);\n      setStyle({\n        animationDuration: `${duration}s`\n      });\n      callbackTORef.current = setTimeout(callback, duration * 1000);\n    }, delay);\n  }, [animating, delay, duration]);\n  const animateInTrigger = useCallback(callback => {\n    animate(animateIn, () => {\n      if (!animateOnce) {\n        setStyle({\n          animationDuration: `${duration}s`,\n          opacity: 1\n        });\n        animating.current = false;\n      }\n\n      const vis = getVisibility();\n\n      if (callback) {\n        callback(vis);\n      }\n    });\n  }, [animating, animateIn, animateOnce, duration, animate, getVisibility]);\n  const animateOutTrigger = useCallback(callback => {\n    animate(animateOut, () => {\n      setClasses(animatedClass);\n      setStyle({\n        animationDuration: `${duration}s`,\n        opacity: 0\n      });\n      const vis = getVisibility();\n\n      if (vis.inViewport && animateIn) {\n        animateInTrigger(afterAnimatedIn);\n      } else {\n        animating.current = false;\n      }\n\n      if (callback) {\n        callback(vis);\n      }\n    });\n  }, [animating, animate, animateIn, duration, afterAnimatedIn, animateInTrigger, animateOut, getVisibility]);\n  const handleScroll = useCallback(() => {\n    if (!animating.current) {\n      const {\n        current: visibility\n      } = visibilityRef;\n      const currentVis = getVisibility();\n\n      if (visibilityHasChanged(visibility, currentVis)) {\n        clearTimeout(delayedAnimationTORef.current);\n\n        if (!currentVis.onScreen) {\n          setClasses(animatedClass);\n          setStyle({\n            animationDuration: `${duration}s`,\n            opacity: initiallyVisible ? 1 : 0\n          });\n        } else if (currentVis.inViewport && animateIn) {\n          animateInTrigger(afterAnimatedIn);\n        } else if (currentVis.onScreen && visibility.inViewport && animateOut && node.current.style.opacity === '1') {\n          animateOutTrigger(afterAnimatedOut);\n        }\n\n        visibilityRef.current = currentVis;\n      }\n    }\n  }, [afterAnimatedIn, afterAnimatedOut, animateIn, animateInTrigger, animateOut, duration, initiallyVisible, visibilityHasChanged, animateOutTrigger, getVisibility]);\n  const listener = useMemo(() => throttle(() => {\n    handleScroll();\n  }, 50), [handleScroll]);\n  useEffect(() => {\n    if (!serverSide) {\n      const parentSelector = scrollableParentSelector;\n      scrollableParentRef.current = parentSelector ? document.querySelector(parentSelector) : window;\n\n      if (scrollableParentRef.current && scrollableParentRef.current.addEventListener) {\n        scrollableParentRef.current.addEventListener('scroll', listener);\n      } else {\n        console.warn(`Cannot find element by locator: ${scrollableParentSelector}`);\n      }\n\n      if (animatePreScroll) {\n        handleScroll();\n      }\n\n      return () => {\n        clearTimeout(delayedAnimationTORef.current);\n        clearTimeout(callbackTORef.current);\n\n        if (window && window.removeEventListener) {\n          window.removeEventListener('scroll', listener);\n        }\n      };\n    }\n  }, [handleScroll, scrollableParentSelector, scrollableParentRef, listener, animatePreScroll]);\n  return /*#__PURE__*/React.createElement(\"div\", {\n    ref: node,\n    className: classNameProps ? `${classNameProps} ${classes}` : classes,\n    style: Object.assign({}, style, styleProps)\n  }, children);\n};\nAnimationOnScroll.propTypes = {\n  offset: _pt.number,\n  duration: _pt.number,\n  style: _pt.any,\n  className: _pt.string,\n  initiallyVisible: _pt.bool,\n  animateIn: _pt.string,\n  afterAnimatedIn: _pt.any,\n  animateOut: _pt.string,\n  delay: _pt.number,\n  animatePreScroll: _pt.bool,\n  afterAnimatedOut: _pt.any,\n  scrollableParentSelector: _pt.string,\n  animateOnce: _pt.bool,\n  children: _pt.any\n};","map":{"version":3,"sources":["../../../src/components/AnimationOnScroll.tsx"],"names":["animatedClass","serverSide","offset","duration","style","className","initiallyVisible","animateIn","afterAnimatedIn","animateOut","delay","animatePreScroll","afterAnimatedOut","scrollableParentSelector","animateOnce","children","AnimationOnScroll","useState","animationDuration","opacity","node","useRef","animating","visibilityRef","onScreen","inViewport","delayedAnimationTORef","callbackTORef","scrollableParentRef","getElementTop","useCallback","elm","yPos","getScrollPos","getScrollableParentHeight","getViewportTop","getViewportBottom","isInViewport","y","isAboveViewport","isBelowViewport","isAboveScreen","isBelowScreen","getVisibility","elementTop","elementBottom","visibilityHasChanged","previousVis","currentVis","animate","setTimeout","setClasses","animation","setStyle","animateInTrigger","callback","vis","animateOutTrigger","handleScroll","current","visibility","clearTimeout","listener","useMemo","throttle","useEffect","parentSelector","document","console","window","classNameProps","classes","Object"],"mappings":";AAAA,OAAA,KAAA,IAAA,OAAA,EAAA,WAAA,EAAA,QAAA,EAAA,SAAA,EAAA,MAAA,QAAA,OAAA;AAOA,OAAA,QAAA,MAAA,iBAAA;AAEA,MAAMA,aAAa,GAAnB,mBAAA;AACA,MAAMC,UAAU,GAAG,OAAA,MAAA,KAAnB,WAAA;AAwBA,OAAO,MAAMe,iBAAiB,GAAG,QAepB;AAAA,MAfqB;AAChCd,IAAAA,MAAM,GAD0B,GAAA;AAEhCC,IAAAA,QAAQ,GAFwB,CAAA;AAGhCC,IAAAA,KAAK,EAH2B,UAAA;AAIhCC,IAAAA,SAAS,EAJuB,cAAA;AAKhCC,IAAAA,gBAAgB,GALgB,KAAA;AAAA,IAAA,SAAA;AAAA,IAAA,eAAA;AAAA,IAAA,UAAA;AAShCI,IAAAA,KAAK,GAT2B,CAAA;AAUhCC,IAAAA,gBAAgB,GAVgB,IAAA;AAAA,IAAA,gBAAA;AAAA,IAAA,wBAAA;AAahCG,IAAAA,WAAW,GAbqB,KAAA;AAchCC,IAAAA;AAdgC,GAerB;AACX,QAAM,CAAA,OAAA,EAAA,UAAA,IAAwBE,QAAQ,CAAtC,aAAsC,CAAtC;AACA,QAAM,CAAA,KAAA,EAAA,QAAA,IAAoBA,QAAQ,CAAY;AAC5CC,IAAAA,iBAAiB,EAAG,GAAEf,QADsB,GAAA;AAE5CgB,IAAAA,OAAO,EAAEb,gBAAgB,GAAA,CAAA,GAAO;AAFY,GAAZ,CAAlC;AAKA,QAAMc,IAAsB,GAAGC,MAAM,CAArC,IAAqC,CAArC;AACA,QAAMC,SAA+B,GAAGD,MAAM,CAA9C,KAA8C,CAA9C;AACA,QAAME,aAEL,GAAGF,MAAM,CAAC;AAAEG,IAAAA,QAAQ,EAAV,KAAA;AAAmBC,IAAAA,UAAU,EAAE;AAA/B,GAAD,CAFV;AAIA,QAAMC,qBAAuC,GAAGL,MAAM,CAAtD,SAAsD,CAAtD;AACA,QAAMM,aAA+B,GAAGN,MAAM,CAA9C,SAA8C,CAA9C;AACA,QAAMO,mBAAqC,GAAGP,MAAM,CAApD,MAAoD,CAApD;AAEA,QAAMQ,aAAa,GAAGC,WAAW,CAAEC,GAAD,IAAS;AACzC,QAAIC,IAAI,GAAR,CAAA;;AACA,WAAOD,GAAG,IAAIA,GAAG,CAAHA,SAAAA,KAAPA,SAAAA,IAAsCA,GAAG,CAAHA,SAAAA,KAA7C,SAAA,EAA0E;AACxEC,MAAAA,IAAI,IAAID,GAAG,CAAHA,SAAAA,GAAgBA,GAAG,CAA3BC,SAAAA;AACAD,MAAAA,GAAG,GAAGA,GAAG,CAATA,YAAAA;AACD;;AACD,WAAA,IAAA;AAN+B,GAAA,EAAjC,EAAiC,CAAjC;AASA,QAAME,YAAY,GAAGH,WAAW,CAAC,MAAM;AACrC,QAAIF,mBAAmB,CAAnBA,OAAAA,CAAAA,WAAAA,KAAJ,SAAA,EAA2D;AACzD,aAAOA,mBAAmB,CAAnBA,OAAAA,CAAP,WAAA;AACD;;AACD,WAAOA,mBAAmB,CAAnBA,OAAAA,CAAP,SAAA;AAJ8B,GAAA,EAK7B,CALH,mBAKG,CAL6B,CAAhC;AAOA,QAAMM,yBAAyB,GAAGJ,WAAW,CAAC,MAAM;AAClD,QAAIF,mBAAmB,CAAnBA,OAAAA,CAAAA,WAAAA,KAAJ,SAAA,EAA2D;AACzD,aAAOA,mBAAmB,CAAnBA,OAAAA,CAAP,WAAA;AACD;;AACD,WAAOA,mBAAmB,CAAnBA,OAAAA,CAAP,YAAA;AAJ2C,GAAA,EAK1C,CALH,mBAKG,CAL0C,CAA7C;AAOA,QAAMO,cAAc,GAAGL,WAAW,CAAC,MAAM;AACvC,WAAOG,YAAY,KAAnB,MAAA;AADgC,GAAA,EAE/B,CAAA,MAAA,EAFH,YAEG,CAF+B,CAAlC;AAIA,QAAMG,iBAAiB,GAAGN,WAAW,CAAC,MAAM;AAC1C,WAAOG,YAAY,KAAKC,yBAAjBD,EAAAA,GAAP,MAAA;AADmC,GAAA,EAElC,CAAA,MAAA,EAAA,YAAA,EAFH,yBAEG,CAFkC,CAArC;AAIA,QAAMI,YAAY,GAAGP,WAAW,CAC7BQ,CAAD,IAAO;AACL,WAAOA,CAAC,IAAIH,cAALG,EAAAA,IAAyBA,CAAC,IAAIF,iBAArC,EAAA;AAF4B,GAAA,EAI9B,CAAA,cAAA,EAJF,iBAIE,CAJ8B,CAAhC;AAOA,QAAMG,eAAe,GAAGT,WAAW,CAChCQ,CAAD,IAAO;AACL,WAAOA,CAAC,GAAGH,cAAX,EAAA;AAF+B,GAAA,EAIjC,CAJF,cAIE,CAJiC,CAAnC;AAOA,QAAMK,eAAe,GAAGV,WAAW,CAChCQ,CAAD,IAAO;AACL,WAAOA,CAAC,GAAGF,iBAAX,EAAA;AAF+B,GAAA,EAIjC,CAJF,iBAIE,CAJiC,CAAnC;AAOA,QAAMX,UAAU,GAAGK,WAAW,CAC5B,CAAA,UAAA,EAAA,aAAA,KAA+B;AAC7B,WACEO,YAAY,CAAZA,UAAY,CAAZA,IACAA,YAAY,CADZA,aACY,CADZA,IAECE,eAAe,CAAfA,UAAe,CAAfA,IAA+BC,eAAe,CAHjD,aAGiD,CAHjD;AAF0B,GAAA,EAQ5B,CAAA,YAAA,EAAA,eAAA,EARF,eAQE,CAR4B,CAA9B;AAWA,QAAMC,aAAa,GAAGX,WAAW,CAC9BQ,CAAD,IAAO;AACL,WAAOA,CAAC,GAAGL,YAAX,EAAA;AAF6B,GAAA,EAI/B,CAJF,YAIE,CAJ+B,CAAjC;AAOA,QAAMS,aAAa,GAAGZ,WAAW,CAC9BQ,CAAD,IAAO;AACL,WAAOA,CAAC,GAAGL,YAAY,KAAKC,yBAA5B,EAAA;AAF6B,GAAA,EAI/B,CAAA,YAAA,EAJF,yBAIE,CAJ+B,CAAjC;AAOA,QAAMV,QAAQ,GAAGM,WAAW,CAC1B,CAAA,UAAA,EAAA,aAAA,KAA+B;AAC7B,WAAO,CAACW,aAAa,CAAd,aAAc,CAAd,IAAiC,CAACC,aAAa,CAAtD,UAAsD,CAAtD;AAFwB,GAAA,EAI1B,CAAA,aAAA,EAJF,aAIE,CAJ0B,CAA5B;AAOA,QAAMC,aAAa,GAAGb,WAAW,CAAC,MAAM;AACtC,UAAMc,UAAU,GACdf,aAAa,CAACT,IAAI,CAAlBS,OAAa,CAAbA,GAA8BA,aAAa,CAACD,mBAAmB,CADjE,OAC6C,CAD7C;AAEA,UAAMiB,aAAa,GAAGD,UAAU,GAAGxB,IAAI,CAAJA,OAAAA,CAAnC,YAAA;AAEA,WAAO;AACLK,MAAAA,UAAU,EAAEA,UAAU,CAAA,UAAA,EADjB,aACiB,CADjB;AAELD,MAAAA,QAAQ,EAAEA,QAAQ,CAAA,UAAA,EAAA,aAAA;AAFb,KAAP;AAL+B,GAAA,EAS9B,CAAA,aAAA,EAAA,IAAA,EAAA,UAAA,EAAA,QAAA,EATH,mBASG,CAT8B,CAAjC;AAWA,QAAMsB,oBAAoB,GAAGhB,WAAW,CAAC,CAAA,WAAA,EAAA,UAAA,KAA6B;AACpE,WACEiB,WAAW,CAAXA,UAAAA,KAA2BC,UAAU,CAArCD,UAAAA,IACAA,WAAW,CAAXA,QAAAA,KAAyBC,UAAU,CAFrC,QAAA;AADsC,GAAA,EAAxC,EAAwC,CAAxC;AAOA,QAAMC,OAAO,GAAGnB,WAAW,CACzB,CAAA,SAAA,EAAA,QAAA,KAAyB;AACvBJ,IAAAA,qBAAqB,CAArBA,OAAAA,GAAgCwB,UAAU,CAAC,MAAM;AAC/C5B,MAAAA,SAAS,CAATA,OAAAA,GAAAA,IAAAA;AACA6B,MAAAA,UAAU,CAAE,GAAEnD,aAAc,IAAGoD,SAA/BD,EAAU,CAAVA;AACAE,MAAAA,QAAQ,CAAC;AAAEnC,QAAAA,iBAAiB,EAAG,GAAEf,QAAS;AAAjC,OAAD,CAARkD;AACA1B,MAAAA,aAAa,CAAbA,OAAAA,GAAwBuB,UAAU,CAAA,QAAA,EAAW/C,QAAQ,GAArDwB,IAAkC,CAAlCA;AAJwC,KAAA,EAA1CD,KAA0C,CAA1CA;AAFuB,GAAA,EASzB,CAAA,SAAA,EAAA,KAAA,EATF,QASE,CATyB,CAA3B;AAYA,QAAM4B,gBAAgB,GAAGxB,WAAW,CACjCyB,QAAD,IAAc;AACZN,IAAAA,OAAO,CAAA,SAAA,EAAY,MAAM;AACvB,UAAI,CAAJ,WAAA,EAAkB;AAChBI,QAAAA,QAAQ,CAAC;AACPnC,UAAAA,iBAAiB,EAAG,GAAEf,QADf,GAAA;AAEPgB,UAAAA,OAAO,EAAE;AAFF,SAAD,CAARkC;AAIA/B,QAAAA,SAAS,CAATA,OAAAA,GAAAA,KAAAA;AACD;;AACD,YAAMkC,GAAG,GAAGb,aAAZ,EAAA;;AACA,UAAA,QAAA,EAAc;AACZY,QAAAA,QAAQ,CAARA,GAAQ,CAARA;AACD;AAXHN,KAAO,CAAPA;AAFgC,GAAA,EAgBlC,CAAA,SAAA,EAAA,SAAA,EAAA,WAAA,EAAA,QAAA,EAAA,OAAA,EAhBF,aAgBE,CAhBkC,CAApC;AAmBA,QAAMQ,iBAAiB,GAAG3B,WAAW,CAClCyB,QAAD,IAAc;AACZN,IAAAA,OAAO,CAAA,UAAA,EAAa,MAAM;AACxBE,MAAAA,UAAU,CAAVA,aAAU,CAAVA;AACAE,MAAAA,QAAQ,CAAC;AAAEnC,QAAAA,iBAAiB,EAAG,GAAEf,QAAxB,GAAA;AAAqCgB,QAAAA,OAAO,EAAE;AAA9C,OAAD,CAARkC;AACA,YAAMG,GAAG,GAAGb,aAAZ,EAAA;;AAEA,UAAIa,GAAG,CAAHA,UAAAA,IAAJ,SAAA,EAAiC;AAC/BF,QAAAA,gBAAgB,CAAhBA,eAAgB,CAAhBA;AADF,OAAA,MAEO;AACLhC,QAAAA,SAAS,CAATA,OAAAA,GAAAA,KAAAA;AACD;;AAED,UAAA,QAAA,EAAc;AACZiC,QAAAA,QAAQ,CAARA,GAAQ,CAARA;AACD;AAbHN,KAAO,CAAPA;AAFiC,GAAA,EAkBnC,CAAA,SAAA,EAAA,OAAA,EAAA,SAAA,EAAA,QAAA,EAAA,eAAA,EAAA,gBAAA,EAAA,UAAA,EAlBF,aAkBE,CAlBmC,CAArC;AA8BA,QAAMS,YAAY,GAAG5B,WAAW,CAAC,MAAM;AACrC,QAAI,CAACR,SAAS,CAAd,OAAA,EAAwB;AACtB,YAAM;AAAEqC,QAAAA,OAAO,EAAEC;AAAX,UAAN,aAAA;AACA,YAAMZ,UAAU,GAAGL,aAAnB,EAAA;;AACA,UAAIG,oBAAoB,CAAA,UAAA,EAAxB,UAAwB,CAAxB,EAAkD;AAChDe,QAAAA,YAAY,CAACnC,qBAAqB,CAAlCmC,OAAY,CAAZA;;AACA,YAAI,CAACb,UAAU,CAAf,QAAA,EAA0B;AACxBG,UAAAA,UAAU,CAAVA,aAAU,CAAVA;AACAE,UAAAA,QAAQ,CAAC;AACPnC,YAAAA,iBAAiB,EAAG,GAAEf,QADf,GAAA;AAEPgB,YAAAA,OAAO,EAAEb,gBAAgB,GAAA,CAAA,GAAO;AAFzB,WAAD,CAAR+C;AAFF,SAAA,MAMO,IAAIL,UAAU,CAAVA,UAAAA,IAAJ,SAAA,EAAwC;AAC7CM,UAAAA,gBAAgB,CAAhBA,eAAgB,CAAhBA;AADK,SAAA,MAEA,IACLN,UAAU,CAAVA,QAAAA,IACAY,UAAU,CADVZ,UAAAA,IAAAA,UAAAA,IAGA5B,IAAI,CAAJA,OAAAA,CAAAA,KAAAA,CAAAA,OAAAA,KAJK,GAAA,EAKL;AACAqC,UAAAA,iBAAiB,CAAjBA,gBAAiB,CAAjBA;AACD;;AACDlC,QAAAA,aAAa,CAAbA,OAAAA,GAAAA,UAAAA;AACD;AACF;AAxB6B,GAAA,EAyB7B,CAAA,eAAA,EAAA,gBAAA,EAAA,SAAA,EAAA,gBAAA,EAAA,UAAA,EAAA,QAAA,EAAA,gBAAA,EAAA,oBAAA,EAAA,iBAAA,EAzBH,aAyBG,CAzB6B,CAAhC;AAsCA,QAAMuC,QAAQ,GAAGC,OAAO,CACtB,MACEC,QAAQ,CAAC,MAAM;AACbN,IAAAA,YAAY;AADN,GAAA,EAFY,EAEZ,CAFY,EAKtB,CALF,YAKE,CALsB,CAAxB;AAQAO,EAAAA,SAAS,CAAC,MAAM;AACd,QAAI,CAAJ,UAAA,EAAiB;AACf,YAAMC,cAAc,GAApB,wBAAA;AACAtC,MAAAA,mBAAmB,CAAnBA,OAAAA,GAA8BsC,cAAc,GACxCC,QAAQ,CAARA,aAAAA,CADwC,cACxCA,CADwC,GAA5CvC,MAAAA;;AAGA,UACEA,mBAAmB,CAAnBA,OAAAA,IACAA,mBAAmB,CAAnBA,OAAAA,CAFF,gBAAA,EAGE;AACAA,QAAAA,mBAAmB,CAAnBA,OAAAA,CAAAA,gBAAAA,CAAAA,QAAAA,EAAAA,QAAAA;AAJF,OAAA,MAKO;AACLwC,QAAAA,OAAO,CAAPA,IAAAA,CACG,mCAAkCvD,wBADrCuD,EAAAA;AAGD;;AACD,UAAA,gBAAA,EAAsB;AACpBV,QAAAA,YAAY;AACb;;AAED,aAAO,MAAM;AACXG,QAAAA,YAAY,CAACnC,qBAAqB,CAAlCmC,OAAY,CAAZA;AACAA,QAAAA,YAAY,CAAClC,aAAa,CAA1BkC,OAAY,CAAZA;;AACA,YAAIQ,MAAM,IAAIA,MAAM,CAApB,mBAAA,EAA0C;AACxCA,UAAAA,MAAM,CAANA,mBAAAA,CAAAA,QAAAA,EAAAA,QAAAA;AACD;AALH,OAAA;AAOD;AA3BM,GAAA,EA4BN,CAAA,YAAA,EAAA,wBAAA,EAAA,mBAAA,EAAA,QAAA,EA5BHJ,gBA4BG,CA5BM,CAATA;AAoCA,SAAA,aACE,KAAA,CAAA,aAAA,CAAA,KAAA,EAAA;AACE,IAAA,GAAG,EADL,IAAA;AAEE,IAAA,SAAS,EAAEK,cAAc,GAAI,GAAEA,cAAe,IAAGC,OAAxB,EAAA,GAF3B,OAAA;AAGE,IAAA,KAAK,EAAEC,MAAM,CAANA,MAAAA,CAAAA,EAAAA,EAAAA,KAAAA,EAAAA,UAAAA;AAHT,GAAA,EADF,QACE,CADF;AArRK,CAAA;;AArBLtE,EAAAA,M;AACAC,EAAAA,Q;AACAC,EAAAA,K;AACAC,EAAAA,S;AACAC,EAAAA,gB;AACAC,EAAAA,S;AACAC,EAAAA,e;AACAC,EAAAA,U;AACAC,EAAAA,K;AACAC,EAAAA,gB;AACAC,EAAAA,gB;AACAC,EAAAA,wB;AACAC,EAAAA,W;AACAC,EAAAA,Q","sourcesContent":["import React, {\n  useMemo,\n  useCallback,\n  useState,\n  useEffect,\n  useRef,\n} from 'react';\nimport throttle from 'lodash.throttle';\n\nconst animatedClass = 'animate__animated';\nconst serverSide = typeof window === 'undefined';\n\ntype Props = {\n  offset?: number;\n  duration?: number;\n  style?: any;\n  className?: string;\n  initiallyVisible?: boolean;\n  animateIn?: string;\n  afterAnimatedIn?: any;\n  animateOut?: string;\n  delay?: number;\n  animatePreScroll?: boolean;\n  afterAnimatedOut?: any;\n  scrollableParentSelector?: string;\n  animateOnce?: boolean;\n  children?: any;\n};\n\ntype styleProp = {\n  animationDuration: string;\n  opacity?: number;\n};\n\nexport const AnimationOnScroll = ({\n  offset = 150,\n  duration = 1,\n  style: styleProps,\n  className: classNameProps,\n  initiallyVisible = false,\n  animateIn,\n  afterAnimatedIn,\n  animateOut,\n  delay = 0,\n  animatePreScroll = true,\n  afterAnimatedOut,\n  scrollableParentSelector,\n  animateOnce = false,\n  children,\n}: Props) => {\n  const [classes, setClasses] = useState(animatedClass);\n  const [style, setStyle] = useState<styleProp>({\n    animationDuration: `${duration}s`,\n    opacity: initiallyVisible ? 1 : 0,\n  });\n\n  const node: { current: any } = useRef(null);\n  const animating: { current: boolean } = useRef(false);\n  const visibilityRef: {\n    current: { onScreen: boolean; inViewport: boolean };\n  } = useRef({ onScreen: false, inViewport: false });\n\n  const delayedAnimationTORef: { current: any } = useRef(undefined);\n  const callbackTORef: { current: any } = useRef(undefined);\n  const scrollableParentRef: { current: any } = useRef(window);\n\n  const getElementTop = useCallback((elm) => {\n    let yPos = 0;\n    while (elm && elm.offsetTop !== undefined && elm.clientTop !== undefined) {\n      yPos += elm.offsetTop + elm.clientTop;\n      elm = elm.offsetParent;\n    }\n    return yPos;\n  }, []);\n\n  const getScrollPos = useCallback(() => {\n    if (scrollableParentRef.current.pageYOffset !== undefined) {\n      return scrollableParentRef.current.pageYOffset;\n    }\n    return scrollableParentRef.current.scrollTop;\n  }, [scrollableParentRef]);\n\n  const getScrollableParentHeight = useCallback(() => {\n    if (scrollableParentRef.current.innerHeight !== undefined) {\n      return scrollableParentRef.current.innerHeight;\n    }\n    return scrollableParentRef.current.clientHeight;\n  }, [scrollableParentRef]);\n\n  const getViewportTop = useCallback(() => {\n    return getScrollPos() + offset;\n  }, [offset, getScrollPos]);\n\n  const getViewportBottom = useCallback(() => {\n    return getScrollPos() + getScrollableParentHeight() - offset;\n  }, [offset, getScrollPos, getScrollableParentHeight]);\n\n  const isInViewport = useCallback(\n    (y) => {\n      return y >= getViewportTop() && y <= getViewportBottom();\n    },\n    [getViewportTop, getViewportBottom]\n  );\n\n  const isAboveViewport = useCallback(\n    (y) => {\n      return y < getViewportTop();\n    },\n    [getViewportTop]\n  );\n\n  const isBelowViewport = useCallback(\n    (y) => {\n      return y > getViewportBottom();\n    },\n    [getViewportBottom]\n  );\n\n  const inViewport = useCallback(\n    (elementTop, elementBottom) => {\n      return (\n        isInViewport(elementTop) ||\n        isInViewport(elementBottom) ||\n        (isAboveViewport(elementTop) && isBelowViewport(elementBottom))\n      );\n    },\n    [isInViewport, isAboveViewport, isBelowViewport]\n  );\n\n  const isAboveScreen = useCallback(\n    (y) => {\n      return y < getScrollPos();\n    },\n    [getScrollPos]\n  );\n\n  const isBelowScreen = useCallback(\n    (y) => {\n      return y > getScrollPos() + getScrollableParentHeight();\n    },\n    [getScrollPos, getScrollableParentHeight]\n  );\n\n  const onScreen = useCallback(\n    (elementTop, elementBottom) => {\n      return !isAboveScreen(elementBottom) && !isBelowScreen(elementTop);\n    },\n    [isAboveScreen, isBelowScreen]\n  );\n\n  const getVisibility = useCallback(() => {\n    const elementTop =\n      getElementTop(node.current) - getElementTop(scrollableParentRef.current);\n    const elementBottom = elementTop + node.current.clientHeight;\n\n    return {\n      inViewport: inViewport(elementTop, elementBottom),\n      onScreen: onScreen(elementTop, elementBottom),\n    };\n  }, [getElementTop, node, inViewport, onScreen, scrollableParentRef]);\n\n  const visibilityHasChanged = useCallback((previousVis, currentVis) => {\n    return (\n      previousVis.inViewport !== currentVis.inViewport ||\n      previousVis.onScreen !== currentVis.onScreen\n    );\n  }, []);\n\n  const animate = useCallback(\n    (animation, callback) => {\n      delayedAnimationTORef.current = setTimeout(() => {\n        animating.current = true;\n        setClasses(`${animatedClass} ${animation}`);\n        setStyle({ animationDuration: `${duration}s` });\n        callbackTORef.current = setTimeout(callback, duration * 1000);\n      }, delay);\n    },\n    [animating, delay, duration]\n  );\n\n  const animateInTrigger = useCallback(\n    (callback) => {\n      animate(animateIn, () => {\n        if (!animateOnce) {\n          setStyle({\n            animationDuration: `${duration}s`,\n            opacity: 1,\n          });\n          animating.current = false;\n        }\n        const vis = getVisibility();\n        if (callback) {\n          callback(vis);\n        }\n      });\n    },\n    [animating, animateIn, animateOnce, duration, animate, getVisibility]\n  );\n\n  const animateOutTrigger = useCallback(\n    (callback) => {\n      animate(animateOut, () => {\n        setClasses(animatedClass);\n        setStyle({ animationDuration: `${duration}s`, opacity: 0 });\n        const vis = getVisibility();\n\n        if (vis.inViewport && animateIn) {\n          animateInTrigger(afterAnimatedIn);\n        } else {\n          animating.current = false;\n        }\n\n        if (callback) {\n          callback(vis);\n        }\n      });\n    },\n    [\n      animating,\n      animate,\n      animateIn,\n      duration,\n      afterAnimatedIn,\n      animateInTrigger,\n      animateOut,\n      getVisibility,\n    ]\n  );\n\n  const handleScroll = useCallback(() => {\n    if (!animating.current) {\n      const { current: visibility } = visibilityRef;\n      const currentVis = getVisibility();\n      if (visibilityHasChanged(visibility, currentVis)) {\n        clearTimeout(delayedAnimationTORef.current);\n        if (!currentVis.onScreen) {\n          setClasses(animatedClass);\n          setStyle({\n            animationDuration: `${duration}s`,\n            opacity: initiallyVisible ? 1 : 0,\n          });\n        } else if (currentVis.inViewport && animateIn) {\n          animateInTrigger(afterAnimatedIn);\n        } else if (\n          currentVis.onScreen &&\n          visibility.inViewport &&\n          animateOut &&\n          node.current.style.opacity === '1'\n        ) {\n          animateOutTrigger(afterAnimatedOut);\n        }\n        visibilityRef.current = currentVis;\n      }\n    }\n  }, [\n    afterAnimatedIn,\n    afterAnimatedOut,\n    animateIn,\n    animateInTrigger,\n    animateOut,\n    duration,\n    initiallyVisible,\n    visibilityHasChanged,\n    animateOutTrigger,\n    getVisibility,\n  ]);\n\n  const listener = useMemo(\n    () =>\n      throttle(() => {\n        handleScroll();\n      }, 50),\n    [handleScroll]\n  );\n\n  useEffect(() => {\n    if (!serverSide) {\n      const parentSelector = scrollableParentSelector;\n      scrollableParentRef.current = parentSelector\n        ? document.querySelector(parentSelector)\n        : window;\n      if (\n        scrollableParentRef.current &&\n        scrollableParentRef.current.addEventListener\n      ) {\n        scrollableParentRef.current.addEventListener('scroll', listener);\n      } else {\n        console.warn(\n          `Cannot find element by locator: ${scrollableParentSelector}`\n        );\n      }\n      if (animatePreScroll) {\n        handleScroll();\n      }\n\n      return () => {\n        clearTimeout(delayedAnimationTORef.current);\n        clearTimeout(callbackTORef.current);\n        if (window && window.removeEventListener) {\n          window.removeEventListener('scroll', listener);\n        }\n      };\n    }\n  }, [\n    handleScroll,\n    scrollableParentSelector,\n    scrollableParentRef,\n    listener,\n    animatePreScroll,\n  ]);\n\n  return (\n    <div\n      ref={node}\n      className={classNameProps ? `${classNameProps} ${classes}` : classes}\n      style={Object.assign({}, style, styleProps)}\n    >\n      {children}\n    </div>\n  );\n};\n"]},"metadata":{},"sourceType":"module"}